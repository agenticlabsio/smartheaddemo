
We'll structure this into the core services involved:

1.  **Chatbook Service (Primary Backend):** Handles chat interactions, intent recognition, orchestration via LangGraph, and session management.
2.  **Cal.com API Wrapper Service:** The existing FastAPI service (`main.py`) that interacts directly with the Cal.com API.
3.  **Supporting Services:** Redis (State), Langfuse (Observability), LLM Provider.

---

**1. Chatbook Service (Primary Backend)**

*   **Purpose:** Acts as the main entry point for the chat interface, orchestrates the conversational flow using LangGraph, manages user sessions, recognizes intent, and interacts with the Cal.com API Wrapper.
*   **Technology:** FastAPI (Python), Langchain, LangGraph, Semantic Router, Pydantic, Redis client (`redis_client.py`), Langfuse SDK.
*   **Deployment:** Likely a containerized service (e.g., Docker) running with Uvicorn/Gunicorn.

**Key Components:**

*   **API Endpoints:** To receive messages and send responses.
*   **Authentication Middleware:** Integrates with the ABC Hospital Network's auth system (e.g., validates JWT tokens passed from the frontend).
*   **Intent Recognizer:** Uses Semantic Router or a similar mechanism to classify incoming messages.
*   **Session Manager:** Loads/saves conversation state (`BookingState`) from/to Redis using `redis_client.py`.
*   **LangGraph Orchestrator:** Initializes and invokes the compiled `booking_graph` (`langchain_bot.py`) with the user message and session state.
*   **Langfuse Integration:** Initializes Langfuse and ensures traces/spans are generated by LangGraph nodes.
*   **Configuration:** Loads API keys (LLM, Langfuse), Redis URL, JWT secrets, etc., from environment variables (`.env`).

**APIs Exposed:**

*   **`POST /chat/message`**
    *   **Purpose:** Receive a user's message, process it through the conversational flow, and return the chatbot's response.
    *   **Authentication:** Requires valid ABC Hospital Network authentication (e.g., `Authorization: Bearer <abc_user_jwt>`). The middleware decodes the token to extract `user_id` and potentially other context.
    *   **Request Body:**
        ```json
        {
          "message": "I need to book an appointment for my daughter Jane.",
          "session_id": "optional_existing_session_id_if_known_by_client" // Optional, backend usually manages via user_id
        }
        ```
    *   **Processing Steps:**
        1.  Authenticate request, extract `user_id`.
        2.  Generate/retrieve `session_id` (e.g., `chatbook:{user_id}`).
        3.  Load existing `BookingState` from Redis using `session_id` (via `redis_client.load_session` or similar, adapted for chat state). If no state, initialize a new one.
        4.  **(If first message or state is clean):** Run Intent Recognition on `message`.
        5.  **If Booking Intent:**
            *   Initialize Langfuse trace for the session if not already started.
            *   Prepare input for LangGraph: `{"user_id": user_id, "session_id": session_id, "user_message": message, ...current_state}`.
            *   Invoke the `booking_graph`: `result = booking_graph.invoke(input_data, config={"configurable": {"session_id": session_id}})` (LangGraph uses config for state management).
            *   The graph execution updates the state internally and interacts with LLM, Redis, Cal.com Wrapper, Langfuse.
            *   Extract the bot's response message(s) from the `result` (e.g., `result.get('last_bot_message')`).
            *   Save the final updated `BookingState` back to Redis (likely handled within the graph's exit node or via LangGraph's checkpointing mechanism).
        6.  **If Not Booking Intent:** Handle appropriately (e.g., generic response, pass to different handler).
        7.  Ensure Langfuse data is flushed if needed.
    *   **Response Body (Success - 200 OK):**
        ```json
        {
          "response": "Okay, I can help with that! Who is this appointment for? Options: Myself, Jane Doe (Child).",
          "session_id": "chatbook:u123" // Return session ID for potential client use
          // Optional: Add context like suggested actions/buttons if UI supports it
        }
        ```
    *   **Response Body (Error - e.g., 401 Unauthorized, 500 Internal Server Error):**
        ```json
        {
          "error": "Authentication failed." // or "Internal server error processing message."
        }
        ```

---

**2. Cal.com API Wrapper Service (`main.py`)**

*   **Purpose:** Provides a stable internal API interface over the external Cal.com API. Handles Cal.com API key management and basic request/response validation.
*   **Technology:** FastAPI (Python), `requests`/`httpx`, Pydantic (`models.py`), `python-dotenv`.
*   **Deployment:** Containerized service, potentially co-located or accessible within the same private network as the Chatbook Service.

**Key Components:**

*   **API Endpoints:** Mirroring Cal.com functionalities needed by Chatbook.
*   **Cal.com API Key Handling:** Securely loads `CAL_API_KEY` from env variables and injects it into requests (`get_cal_api_params`).
*   **Request/Response Validation:** Uses Pydantic models (`models.py`) for input/output structure.
*   **Error Handling:** Catches `requests.RequestException` and translates them into FastAPI `HTTPException`.

**APIs Used by Chatbook Service (subset of `main.py`):**

*   **`GET /users/{user_id}`** (Potentially, if family info isn't passed via initial context)
    *   **Purpose:** Fetch details for a specific user (maybe to confirm name/email or fetch linked profiles if Cal.com supports it).
    *   **Auth:** Internal service call; `apiKey` handled by the wrapper.
    *   **Response:** `User` model (from `models.py`).
*   **`GET /bookings/slots`**
    *   **Purpose:** Find available appointment slots based on criteria.
    *   **Auth:** Internal service call; `apiKey` handled by the wrapper.
    *   **Query Parameters:** `startTime`, `endTime`, `eventTypeId` / `eventTypeSlug` / `usernameList`, `timeZone`, etc. (as defined in `main.py`). Passed by the LangGraph `availability_node`.
    *   **Response:** JSON structure containing available slots (e.g., `{"slots": [{"time": "...", ...}]}`). LangGraph node parses this.
*   **`POST /bookings`**
    *   **Purpose:** Create a new appointment booking.
    *   **Auth:** Internal service call; `apiKey` handled by the wrapper.
    *   **Request Body:** JSON structure matching Cal.com's booking creation payload, constructed by the LangGraph `confirmation_node` from `BookingState`. Needs fields like `eventTypeId`, `start`, `end`, `responses` (for custom fields), `attendees` (name, email, timezone). *Crucially, attendee details come from the `BookingState` (patient info)*.
    *   **Response (Success):** JSON containing the created `Booking` details (including `id`, `uid`, potentially assigned host if 'any' was chosen).
    *   **Response (Conflict - 409):** Indicates the slot was taken.
    *   **Response (Error):** Other status codes for validation errors or Cal.com issues.
*   **`GET /event-types`** (Potentially)
    *   **Purpose:** Fetch available event types, maybe to help resolve user preferences (e.g., map "check-up" to a specific `eventTypeId`).
    *   **Auth:** Internal service call; `apiKey` handled by the wrapper.
    *   **Response:** List of `EventType` objects.
*   *(Other endpoints like `GET /schedules`, `GET /attendees` might be needed depending on the sophistication of the conversational flow and how preferences are resolved).*

---

**3. Supporting Services**

*   **Redis Service**
    *   **Purpose:** Store temporary conversational state (`BookingState`).
    *   **Technology:** Redis (e.g., Upstash).
    *   **Interface:** Accessed via `redis-py` or `upstash-redis` library using functions defined in `redis_client.py`.
    *   **Key Operations Used:**
        *   `SETEX key seconds value`: To save/update the `BookingState` JSON string with a TTL. (Key: `session:chatbook:{user_id}`)
        *   `GET key`: To retrieve the `BookingState` JSON string.
        *   `DEL key`: To clear the state upon explicit cancellation or session end.
*   **Langfuse Service**
    *   **Purpose:** Observability, tracing, debugging, monitoring LLM interactions.
    *   **Technology:** Langfuse Cloud or self-hosted instance.
    *   **Interface:** Accessed via the `langfuse` Python SDK.
    *   **Key Operations Used:**
        *   `Langfuse()`: Initialization with API keys.
        *   `langfuse.trace()`: Create a trace per chat session.
        *   `trace.span()`: Create spans for LangGraph nodes, LLM calls, API calls.
        *   `trace.update()`: Add metadata like `user_id`.
        *   `langfuse.flush()`: Ensure data is sent.
*   **LLM Provider Service**
    *   **Purpose:** Provide NLU and NLG capabilities.
    *   **Technology:** OpenAI API, Azure OpenAI Service, or other compatible provider.
    *   **Interface:** Accessed via Langchain abstractions (e.g., `ChatOpenAI`) which handle the underlying API calls. Requires provider's API key.

---

**Data Flow Example (Happy Path Booking):**

1.  **User (ABC App Frontend)** sends message (`"Book for Jane"`) -> `POST /chat/message` (Chatbook Service).
2.  **Chatbook Service:** Authenticates user (`u123`), gets/creates `session_id`, loads state from Redis (empty), recognizes Booking Intent.
3.  **Chatbook Service:** Invokes `booking_graph` (`session_id=chatbook:u123`, `user_message="Book for Jane"`).
4.  **`start_node` (LangGraph):** Initializes Langfuse trace, loads user context (`u123`, family=`["Jane Doe"]`). Updates `BookingState`.
5.  **`patient_selection_node` (LangGraph):** Generates prompt ("Who for? Myself, Jane Doe") using LLM, sends response back via Chatbook Service -> User.
6.  **User:** Sends reply (`"Jane Doe"`) -> `POST /chat/message`.
7.  **Chatbook Service:** Invokes `booking_graph` with new message and existing state.
8.  **`patient_selection_node` (LangGraph):** Processes reply, updates `BookingState` (`selected_family_member_id="jane_id"`, `patient_name="Jane Doe"`).
9.  **`reason_node` (LangGraph):** Asks for reason via LLM -> User.
10. **User:** Sends reason (`"cough"`) -> `POST /chat/message`.
11. **`reason_node` (LangGraph):** Extracts reason, updates `BookingState`.
12. ... (Preferences collected similarly) ...
13. **`availability_node` (LangGraph):**
    *   Reads preferences from `BookingState`.
    *   Calls `GET /bookings/slots?eventTypeId=...&startTime=...` (Cal.com Wrapper Service).
    *   **Cal.com Wrapper:** Adds API key, calls Cal.com, returns slots.
    *   `availability_node` receives slots, updates `BookingState`, uses LLM to format slots -> User.
14. **User:** Selects slot (`"10 AM"`) -> `POST /chat/message`.
15. **`slot_selection_node` (LangGraph):** Parses selection, updates `BookingState` (`selected_slot=...`).
16. **`summary_node` (LangGraph):** Formats summary from `BookingState` via LLM -> User.
17. **User:** Confirms (`"Yes"`) -> `POST /chat/message`.
18. **`confirmation_node` (LangGraph):**
    *   Constructs payload from `BookingState`.
    *   Calls `POST /bookings` (Cal.com Wrapper Service) with payload.
    *   **Cal.com Wrapper:** Adds API key, calls Cal.com. Cal.com books, returns success + details. Wrapper returns details.
    *   `confirmation_node` receives success, updates `BookingState` (`confirmation_details=...`), uses LLM to format confirmation -> User.
19. **`exit_node` (LangGraph):** Saves final state to Redis, finalizes Langfuse trace.
20. **Chatbook Service:** Returns final confirmation message to User.

This detailed breakdown covers the essential backend services and their APIs required to power the Chatbook conversational booking experience.
